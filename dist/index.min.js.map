{"version":3,"sources":["../dev/index.js"],"names":["IMGArrays","[object Object]","array","alpha","file","lDecZeroes","width","Math","ceil","sqrt","length","capacity","constructor","Uint8ClampedArray","this","prepareExportData","height","Promise","resolve","reject","canvas","context","getContext","imgData","getImageData","i","data","putImageData","toBuffer","err","buf","fs","createWriteStream","write","document","createElement","readFile","base64","toString","img","Image","src","split","reverse","drawImage","stringRepresentation","pixelString","c","padStart","values","shift","hexToNum","prepareImportData","remainder","parts","numToHex","match","p","push","parseInt","hex","undefined","positive","slice","metaOffset","meta","valuesIn","replace","right","left","leadingDecZeroes","parseFloat","repeat","num","sign","abs","Number","isInteger","test","toFixed","cap","min","rightString","exec","minVal","Infinity","maxVal","name","format","link","download","toBlob","blob","href","URL","createObjectURL","click","window","exports","require"],"mappings":"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","file":"index.min.js","sourcesContent":["\"use strict\"\r\n\r\n/*\r\n    TODO\r\n        - Toggleable use of normalization, saving min and max values at the start, behind/between a FF delimiter\r\n        - Automatically choose the best capacity size, by parsing all values first, checking for limits\r\n*/\r\n\r\nclass IMGArrays {\r\n\r\n    static toIMG (array, {alpha=false, file=false, lDecZeroes=true, width=Math.ceil(Math.sqrt(array.length*(alpha?3:4))), capacity=1}={}) {\r\n\r\n        // Convert the array values to Uint8Clamped values (Base 15 with 16th value used as metadata)\r\n        array = array.constructor == Uint8ClampedArray ? array : this.prepareExportData(array, capacity, lDecZeroes)\r\n\r\n        const height = Math.ceil((array.length/(alpha ? 4 : 3)) / width)\r\n\r\n        // Write to file\r\n        if (file) {\r\n            return new Promise((resolve, reject) => {\r\n\r\n                const canvas = new this.canvas(width, height)\r\n                const context = canvas.getContext(\"2d\")\r\n                const imgData = context.getImageData(0, 0, canvas.width, canvas.height)\r\n\r\n                if (alpha) {\r\n                    for (let i=0; i<array.length; i++) {\r\n                        imgData.data[i] = array[i]\r\n                    }\r\n                    context.putImageData(imgData, 0, 0)\r\n                } else {\r\n                    for (let i=0; i<array.length/3; i++) {\r\n                        imgData.data[i*4]   = array[i*3]\r\n                        imgData.data[i*4+1] = array[i*3+1]\r\n                        imgData.data[i*4+2] = array[i*3+2]\r\n                        imgData.data[i*4+3] = 255\r\n                    }\r\n                    context.putImageData(imgData, 0, 0)\r\n                }\r\n\r\n                canvas.toBuffer((err, buf) => {\r\n                    const writeStream = this.fs.createWriteStream(file)\r\n                    writeStream.write(buf)\r\n                    resolve()\r\n                    // writeStream.on(\"finish\", () => resolve())\r\n                })\r\n            })\r\n\r\n        } else {\r\n            // Draw to canvas\r\n            const canvas = document.createElement(\"canvas\")\r\n            canvas.width = width\r\n            canvas.height = height\r\n            const context = canvas.getContext(\"2d\")\r\n            const imgData = context.getImageData(0, 0, canvas.width, canvas.height)\r\n\r\n            if (alpha) {\r\n                for (let i=0; i<array.length; i++) {\r\n                    imgData.data[i] = array[i]\r\n                }\r\n                context.putImageData(imgData, 0, 0)\r\n            } else {\r\n                for (let i=0; i<array.length/3; i++) {\r\n                    imgData.data[i*4]   = array[i*3]\r\n                    imgData.data[i*4+1] = array[i*3+1]\r\n                    imgData.data[i*4+2] = array[i*3+2]\r\n                    imgData.data[i*4+3] = 255\r\n                }\r\n                context.putImageData(imgData, 0, 0)\r\n            }\r\n\r\n            return canvas\r\n        }\r\n    }\r\n\r\n    static fromIMG (data, {alpha=false, capacity=1, lDecZeroes=true}={}) {\r\n\r\n        // Read from file\r\n        if (typeof data == \"string\") {\r\n            return new Promise((resolve, reject) => {\r\n\r\n                this.fs.readFile(data, (err, buf) => {\r\n                    const base64 = buf.toString(\"base64\")\r\n                    const img = new this.canvas.Image\r\n                    img.src = `data:image/${data.split(\".\").reverse()[0]};base64,` + base64\r\n\r\n                    const canvas = new this.canvas(img.width, img.height)\r\n                    const context = canvas.getContext(\"2d\")\r\n\r\n                    context.drawImage(img, 0, 0)\r\n                    const imgData = context.getImageData(0, 0, canvas.width, canvas.height).data\r\n\r\n                    let stringRepresentation = \"\"\r\n\r\n                    for (let i=0; i<imgData.length/4; i++) {\r\n\r\n                        let pixelString = \"\"\r\n\r\n                        if (alpha) {\r\n                            for (let c=0; c<4; c++) {\r\n                                pixelString += imgData[i*4+c].toString(16).padStart(2, 0)\r\n                            }\r\n                        } else {\r\n                            for (let c=0; c<3; c++) {\r\n                                pixelString += imgData[i*4+c].toString(16).padStart(2, 0)\r\n                            }\r\n                        }\r\n\r\n                        stringRepresentation += pixelString\r\n                    }\r\n\r\n                    const values = stringRepresentation.split(\"f\")\r\n                    values.shift()\r\n\r\n                    for (let i=0; i<values.length; i++) {\r\n                        values[i] = this.hexToNum(values[i], capacity, lDecZeroes)\r\n                    }\r\n\r\n                    resolve(values)\r\n                })\r\n            })\r\n        } else {\r\n            data = data.constructor == Uint8ClampedArray ? data : this.prepareImportData(data)\r\n\r\n            let stringRepresentation = \"\"\r\n\r\n            for (let i=0; i<data.length/4; i++) {\r\n\r\n                let pixelString = \"\"\r\n\r\n                if (alpha) {\r\n                    for (let c=0; c<4; c++) {\r\n                        pixelString += data[i*4+c].toString(16).padStart(2, 0)\r\n                    }\r\n                } else {\r\n                    for (let c=0; c<3; c++) {\r\n                        pixelString += data[i*4+c].toString(16).padStart(2, 0)\r\n                    }\r\n                }\r\n\r\n                stringRepresentation += pixelString\r\n            }\r\n\r\n            const values = stringRepresentation.split(\"f\")\r\n            values.shift()\r\n\r\n            for (let i=0; i<values.length; i++) {\r\n                values[i] = this.hexToNum(values[i], capacity, lDecZeroes)\r\n            }\r\n\r\n            return values\r\n        }\r\n    }\r\n\r\n\r\n    // Helper functions\r\n    static prepareExportData (array, capacity, lDecZeroes=true) {\r\n\r\n        const data = []\r\n        let remainder = \"\"\r\n\r\n        for (let i=0; i<array.length; i++) {\r\n\r\n            // Convert value to base15\r\n            const base = remainder + this.numToHex(array[i], capacity, lDecZeroes)\r\n            const parts = base.match(/.{1,2}/g)\r\n            const length = parts.length\r\n\r\n            for (let p=0; p<length; p++) {\r\n                if (parts[0].length==2) {\r\n                    data.push(parseInt(`0x${parts.shift()}`))\r\n                }\r\n            }\r\n\r\n            remainder = parts[0] || \"\"\r\n        }\r\n\r\n        while (data.length%3) {\r\n            data.push(0)\r\n        }\r\n\r\n        return new Uint8ClampedArray(data)\r\n    }\r\n\r\n    static prepareImportData (img) {\r\n        const canvas = document.createElement(\"canvas\")\r\n        canvas.height = img.height\r\n        canvas.width = img.width\r\n        const context = canvas.getContext(\"2d\")\r\n        context.drawImage(img, 0, 0)\r\n        return context.getImageData(0, 0, canvas.width, canvas.height).data\r\n    }\r\n\r\n    static hexToNum (hex, capacity=1, lDecZeroes=true) {\r\n\r\n        if (hex==\"00000\") {\r\n            return 0\r\n        }\r\n\r\n        if (hex===undefined) {\r\n            return 0\r\n        }\r\n\r\n        const positive = capacity==2 ? (parseInt(hex.slice(0, 2), 15) >= 112) : (parseInt(hex[0], 16) >= 8)\r\n        const metaOffset = capacity + (lDecZeroes ? 1 : 0)\r\n\r\n        const meta = hex.slice(0, metaOffset)\r\n        hex = hex.replace(meta, \"\")\r\n\r\n        let valuesIn\r\n\r\n        if (capacity==2) {\r\n            valuesIn = parseInt(meta.slice(0, 2), 15) - ((positive ? 112 : 0) - 1)\r\n        } else {\r\n            valuesIn = parseInt(meta[0], 15) - (positive ? 8 : 0) + 1\r\n        }\r\n\r\n        let right = \"\"\r\n        const left = hex.slice(0, valuesIn) || \"0\"\r\n        const leadingDecZeroes = lDecZeroes ? parseInt(meta.slice(capacity, metaOffset), 15) : 0\r\n\r\n        // Return just the decimal part\r\n        if (capacity==0) {\r\n            return parseFloat(\"0.\"+\"0\".repeat(leadingDecZeroes) + parseInt(hex.slice(valuesIn, hex.length), 15))\r\n        }\r\n\r\n        // If the left side's length is smaller than total length (aka a decimal value)\r\n        if (left.length < hex.length) {\r\n            right = \".\"+\"0\".repeat(leadingDecZeroes) + parseInt(hex.slice(valuesIn, hex.length), 15)\r\n        }\r\n\r\n        return (positive ? 1 : -1) * parseFloat(parseInt(left, 15)+right)\r\n    }\r\n\r\n    static numToHex (num, capacity=1, lDecZeroes=true) {\r\n\r\n        let sign\r\n        let leadingDecZeroes = \"0\"\r\n\r\n        if (capacity==2) {\r\n            sign = num > 0 ? 112 : 0\r\n        } else {\r\n            sign = num > 0 ? 8 : 0\r\n        }\r\n\r\n        num = Math.abs(num)\r\n\r\n        // Number is not an integer\r\n        if (!Number.isInteger(num)) {\r\n\r\n            // Discard values below 17 decimal places and return 0\r\n            if (/\\.0{17}$/.test(num.toFixed(17))) {\r\n                return \"F\"+sign.toString(15)+\"0000\"\r\n            }\r\n\r\n            // The left part is capped to the biggest number that can be represented with 8 base15 characters\r\n            let left\r\n            if (capacity==2) {\r\n                left = parseInt(num).toString(15)\r\n            } else {\r\n                const cap = 2562890624 // Math.pow(15, 8)-1\r\n                left = Math.min(parseInt(num), cap).toString(15)\r\n            }\r\n\r\n            const rightString = num.toString().split(\".\")[1]\r\n\r\n            leadingDecZeroes = Math.min(/^0*/.exec(rightString)[0].length, 15).toString(15).padStart((lDecZeroes ? 1 : 0), 0)\r\n            const right = parseInt(rightString).toString(15)\r\n\r\n            sign += left.length-1\r\n\r\n            let meta = \"F\" + (capacity==0 ? \"\" : sign.toString(15).padStart(capacity, 0))\r\n\r\n            if (lDecZeroes) {\r\n                meta += leadingDecZeroes\r\n            }\r\n\r\n            return meta + left+right\r\n        }\r\n\r\n        sign += num.toString(15).length-1\r\n\r\n        let meta = \"F\" + (capacity==0 ? \"\" : sign.toString(15).padStart(capacity, 0))\r\n\r\n        if (lDecZeroes) {\r\n            meta += leadingDecZeroes\r\n        }\r\n\r\n        return meta + num.toString(15)\r\n    }\r\n\r\n    static normalize (data) {\r\n        let minVal = Infinity\r\n        let maxVal = -Infinity\r\n\r\n        for (let i=0; i<data.length; i++) {\r\n            if (data[i] < minVal) {\r\n                minVal = data[i]\r\n            }\r\n            if (data[i] > maxVal) {\r\n                maxVal = data[i]\r\n            }\r\n        }\r\n\r\n        if ((-1*minVal + maxVal) != 0) {\r\n            for (let i=0; i<data.length; i++) {\r\n                data[i] = (data[i] + -1*minVal) / (-1*minVal + maxVal)\r\n            }\r\n        } else {\r\n            for (let i=0; i<data.length; i++) {\r\n                data[i] = 0.5\r\n            }\r\n        }\r\n\r\n        return {minVal, maxVal}\r\n    }\r\n\r\n    static unnormalize (data, minVal, maxVal) {\r\n\r\n        if (maxVal-minVal == 0) {\r\n            for (let i=0; i<data.length; i++) {\r\n                data[i] = (data[i] + 0.5) * minVal\r\n            }\r\n        }\r\n\r\n        for (let i=0; i<data.length; i++) {\r\n            data[i] = data[i] * (-1*minVal + maxVal) - -1*minVal\r\n        }\r\n    }\r\n\r\n    static downloadImage (canvas, {name=\"image\", format=\"webp\"}) {\r\n        const link = document.createElement(\"a\")\r\n        link.download = `${name}.${format}`\r\n\r\n        canvas.toBlob(blob => {\r\n            link.href = URL.createObjectURL(blob)\r\n            link.click()\r\n        }, `image/${format}`, 1)\r\n    }\r\n}\r\n\r\n// https://github.com/DanRuta/jsNet/issues/33\r\n/* istanbul ignore next */\r\nif (typeof window != \"undefined\") {\r\n    window.exports = window.exports || {}\r\n    window.IMGArrays = IMGArrays\r\n} else {\r\n    IMGArrays.fs = require(\"fs\")\r\n    IMGArrays.canvas = require(\"canvas-prebuilt\")\r\n}\r\nexports.IMGArrays = IMGArrays"]}