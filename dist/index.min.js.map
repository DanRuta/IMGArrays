{"version":3,"sources":["../dev/index.js"],"names":["PNGArrays","[object Object]","array","alpha","file","width","Math","ceil","sqrt","length","capacity","constructor","Uint8ClampedArray","this","prepareExportData","height","Promise","resolve","reject","PNG","pngjs2","imgData","data","Buffer","from","i","opti","optipng","pngStream","pack","writeStream","fs","createWriteStream","replace","pipe","on","canvas","document","createElement","context","getContext","getImageData","putImageData","createReadStream","filterType","stringRepresentation","pixelString","c","toString","padStart","values","split","shift","hexToNum","prepareImportData","remainder","parts","numToHex","match","p","push","parseInt","img","drawImage","hex","undefined","positive","slice","metaOffset","meta","valuesIn","right","left","leadingDecZeroes","parseFloat","repeat","num","sign","Number","isInteger","test","toFixed","cap","min","rightString","exec","minVal","Infinity","maxVal","name","link","download","toBlob","blob","href","URL","createObjectURL","click","window","exports","require"],"mappings":"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","file":"index.min.js","sourcesContent":["\"use strict\"\r\n\r\n/*\r\n    TODO\r\n        - Toggleable use of leadingDecZeroes ? would this help in cases where values are not all tiny ?\r\n        - Toggleable use of normalization, saving min and max values at the start, behind/between a FF delimiter\r\n        - Automatically choose the best capacity size, by parsing all values first, checking for limits\r\n*/\r\n\r\nclass PNGArrays {\r\n\r\n    static toPNG (array, {alpha=false, file=false, width=Math.ceil(Math.sqrt(array.length*(alpha?3:4))), capacity=1}={}) {\r\n\r\n        // Convert the array values to Uint8Clamped values (Base 15 with 16th value used as metadata)\r\n        array = array.constructor == Uint8ClampedArray ? array : this.prepareExportData(array, capacity)\r\n\r\n        const height = Math.ceil((array.length/(alpha ? 4 : 3)) / width)\r\n\r\n        // Write to file\r\n        if (file) {\r\n            return new Promise((resolve, reject) => {\r\n\r\n                const PNG = new this.pngjs2({width, height})\r\n                const imgData = new Uint8ClampedArray(array.length/3*4)\r\n\r\n                if (alpha) {\r\n                    PNG.data = Buffer.from(array)\r\n                } else {\r\n                    for (let i=0; i<array.length/3; i++) {\r\n                        imgData[i*4]   = array[i*3]\r\n                        imgData[i*4+1] = array[i*3+1]\r\n                        imgData[i*4+2] = array[i*3+2]\r\n                        imgData[i*4+3] = 255\r\n                    }\r\n                    PNG.data = Buffer.from(imgData)\r\n                }\r\n\r\n                const opti = new this.optipng([\"-o7\"])\r\n                const pngStream = PNG.pack()\r\n                const writeStream = this.fs.createWriteStream(file.replace(/\\.png$/, \"\")+\".png\")\r\n\r\n                pngStream.pipe(opti).pipe(writeStream)\r\n                writeStream.on(\"finish\", () => resolve())\r\n            })\r\n\r\n        } else {\r\n            // Draw to canvas\r\n            const canvas = document.createElement(\"canvas\")\r\n            canvas.width = width\r\n            canvas.height = height\r\n            const context = canvas.getContext(\"2d\")\r\n\r\n            const imgData = context.getImageData(0, 0, canvas.width, canvas.height)\r\n\r\n            if (alpha) {\r\n                context.putImageData(array, 0, 0)\r\n            } else {\r\n                for (let i=0; i<array.length/3; i++) {\r\n                    imgData.data[i*4]   = array[i*3]\r\n                    imgData.data[i*4+1] = array[i*3+1]\r\n                    imgData.data[i*4+2] = array[i*3+2]\r\n                    imgData.data[i*4+3] = 255\r\n                }\r\n                context.putImageData(imgData, 0, 0)\r\n            }\r\n\r\n            return canvas\r\n        }\r\n    }\r\n\r\n    static fromPNG (data, {alpha=false, capacity=1}={}) {\r\n\r\n        // Read from file\r\n        if (typeof data == \"string\") {\r\n            return new Promise((resolve, reject) => {\r\n                const rs = this.fs.createReadStream(data)\r\n\r\n                rs.pipe(new this.pngjs2({filterType: 4}))\r\n                .on(\"parsed\", function () {\r\n\r\n                    let stringRepresentation = \"\"\r\n\r\n                    for (let i=0; i<this.data.length/4; i++) {\r\n\r\n                        let pixelString = \"\"\r\n\r\n                        if (alpha) {\r\n                            for (let c=0; c<4; c++) {\r\n                                pixelString += this.data[i*4+c].toString(16).padStart(2, 0)\r\n                            }\r\n                        } else {\r\n                            for (let c=0; c<3; c++) {\r\n                                pixelString += this.data[i*4+c].toString(16).padStart(2, 0)\r\n                            }\r\n                        }\r\n\r\n                        stringRepresentation += pixelString\r\n                    }\r\n\r\n                    const values = stringRepresentation.split(\"f\")\r\n                    values.shift()\r\n\r\n                    for (let i=0; i<values.length; i++) {\r\n                        values[i] = PNGArrays.hexToNum(values[i], capacity)\r\n                    }\r\n\r\n                    resolve(values)\r\n                })\r\n            })\r\n        } else {\r\n            data = data.constructor == Uint8ClampedArray ? data : this.prepareImportData(data)\r\n\r\n            let stringRepresentation = \"\"\r\n\r\n            for (let i=0; i<data.length/4; i++) {\r\n\r\n                let pixelString = \"\"\r\n\r\n                if (alpha) {\r\n                    for (let c=0; c<4; c++) {\r\n                        pixelString += data[i*4+c].toString(16).padStart(2, 0)\r\n                    }\r\n                } else {\r\n                    for (let c=0; c<3; c++) {\r\n                        pixelString += data[i*4+c].toString(16).padStart(2, 0)\r\n                    }\r\n                }\r\n\r\n                stringRepresentation += pixelString\r\n            }\r\n\r\n            const values = stringRepresentation.split(\"f\")\r\n            values.shift()\r\n\r\n            for (let i=0; i<values.length; i++) {\r\n                values[i] = this.hexToNum(values[i])\r\n            }\r\n\r\n            return values\r\n        }\r\n    }\r\n\r\n\r\n    // Helper functions\r\n    static prepareExportData (array, capacity) {\r\n\r\n        const data = []\r\n        let remainder = \"\"\r\n\r\n        for (let i=0; i<array.length; i++) {\r\n\r\n            // Convert value to base15\r\n            const base = remainder + this.numToHex(array[i], capacity)\r\n            const parts = base.match(/.{1,2}/g)\r\n            const length = parts.length\r\n\r\n            for (let p=0; p<length; p++) {\r\n                if (parts[0].length==2) {\r\n                    data.push(parseInt(`0x${parts.shift()}`))\r\n                }\r\n            }\r\n\r\n            remainder = parts[0] || \"\"\r\n        }\r\n\r\n        while (data.length%3) {\r\n            data.push(0)\r\n        }\r\n\r\n        return new Uint8ClampedArray(data)\r\n    }\r\n\r\n    static prepareImportData (img) {\r\n        const canvas = document.createElement(\"canvas\")\r\n        canvas.height = img.height\r\n        canvas.width = img.width\r\n        const context = canvas.getContext(\"2d\")\r\n        context.drawImage(img, 0, 0)\r\n        return context.getImageData(0, 0, canvas.width, canvas.height).data\r\n    }\r\n\r\n    static hexToNum (hex, capacity=1) {\r\n\r\n        if (hex==\"00000\") {\r\n            return 0\r\n        }\r\n\r\n        if (hex===undefined) {\r\n            return 0\r\n        }\r\n\r\n        const positive = capacity==2 ? (parseInt(hex.slice(0, 2), 15) >= 112) : (parseInt(hex[0], 16) >= 7)\r\n        const metaOffset = capacity+2\r\n\r\n        const meta = hex.slice(0, metaOffset)\r\n        hex = hex.replace(meta, \"\")\r\n\r\n        let valuesIn\r\n\r\n        if (capacity==2) {\r\n            valuesIn = parseInt(meta.slice(0, 2), 15) - ((positive ? 112 : 0) - 1)\r\n        } else {\r\n            valuesIn = parseInt(meta[0], 15) - (positive ? 6 : -1)\r\n        }\r\n\r\n        let right = \"\"\r\n        const left = hex.slice(0, valuesIn) || \"0\"\r\n        const leadingDecZeroes = parseInt(meta.slice(capacity, metaOffset), 15)\r\n\r\n        // Return just the decimal part\r\n        if (capacity==0) {\r\n            return parseFloat(\"0.\"+\"0\".repeat(leadingDecZeroes) + parseInt(hex.slice(valuesIn, hex.length), 15))\r\n        }\r\n\r\n        // If the left side's length is smaller than total length (aka a decimal value)\r\n        if (left.length < hex.length) {\r\n            right = \".\"+\"0\".repeat(leadingDecZeroes) + parseInt(hex.slice(valuesIn, hex.length), 15)\r\n        }\r\n\r\n        return (positive ? 1 : -1) * parseFloat(parseInt(left, 15)+right)\r\n    }\r\n\r\n    static numToHex (num, capacity=1) {\r\n\r\n        let sign\r\n        let leadingDecZeroes = \"00\"\r\n\r\n        if (capacity==2) {\r\n            sign = num > 0 ? 112 : 0\r\n        } else {\r\n            sign = num > 0 ? 7 : 0\r\n        }\r\n\r\n        // Number is not an integer\r\n        if (!Number.isInteger(num)) {\r\n\r\n            // Discard values below 17 decimal places and return 0\r\n            if (/\\.0{17}$/.test(num.toFixed(17))) {\r\n                return \"F\"+sign.toString(15)+\"0000\"\r\n            }\r\n\r\n            // The left part is capped to the biggest number that can be represented with 8 base15 characters\r\n            let left\r\n            if (capacity==2) {\r\n                left = parseInt(num).toString(15)\r\n            } else {\r\n                const cap = 2562890624 // Math.pow(15, 8)-1\r\n                left = Math.min(parseInt(num), cap).toString(15)\r\n            }\r\n\r\n            const rightString = num.toString().split(\".\")[1]\r\n\r\n            leadingDecZeroes = Math.min(/^0*/.exec(rightString)[0].length, 15).toString(15).padStart(2, 0)\r\n            const right = parseInt(rightString).toString(15)\r\n\r\n            sign += left.length-1\r\n\r\n            const meta = \"F\" + (capacity==0 ? \"\" : sign.toString(15).padStart(capacity, 0)) + leadingDecZeroes\r\n            return meta + left+right\r\n        }\r\n\r\n        sign += num.toString().length-1\r\n\r\n        const meta = \"F\" + (capacity==0 ? \"\" : sign.toString(15).padStart(capacity, 0)) + leadingDecZeroes\r\n        return meta + num.toString(15)\r\n    }\r\n\r\n    static normalize (data) {\r\n        let minVal = Infinity\r\n        let maxVal = -Infinity\r\n\r\n        for (let i=0; i<data.length; i++) {\r\n            if (data[i] < minVal) {\r\n                minVal = data[i]\r\n            }\r\n            if (data[i] > maxVal) {\r\n                maxVal = data[i]\r\n            }\r\n        }\r\n\r\n        if ((-1*minVal + maxVal) != 0) {\r\n            for (let i=0; i<data.length; i++) {\r\n                data[i] = (data[i] + -1*minVal) / (-1*minVal + maxVal)\r\n            }\r\n        } else {\r\n            for (let i=0; i<data.length; i++) {\r\n                data[i] = 0.5\r\n            }\r\n        }\r\n\r\n        return {minVal, maxVal}\r\n    }\r\n\r\n    static unnormalize (data, minVal, maxVal) {\r\n\r\n        if (maxVal-minVal == 0) {\r\n            for (let i=0; i<data.length; i++) {\r\n                data[i] = (data[i] + 0.5) * minVal\r\n            }\r\n        }\r\n\r\n        for (let i=0; i<data.length; i++) {\r\n            data[i] = data[i] * (-1*minVal + maxVal) - -1*minVal\r\n        }\r\n    }\r\n\r\n    static downloadImage (canvas, {name=\"image\"}) {\r\n        const link = document.createElement(\"a\")\r\n        link.download = `${name}.png`\r\n\r\n        canvas.toBlob(blob => {\r\n            link.href = URL.createObjectURL(blob)\r\n            link.click()\r\n        }, `image/png`, 1)\r\n    }\r\n}\r\n\r\n\r\n// https://github.com/DanRuta/jsNet/issues/33\r\n/* istanbul ignore next */\r\nif (typeof window != \"undefined\") {\r\n    window.exports = window.exports || {}\r\n    window.PNGArrays = PNGArrays\r\n} else {\r\n    PNGArrays.fs = require(\"fs\")\r\n    PNGArrays.pngjs2 = require(\"pngjs2\").PNG\r\n    PNGArrays.optipng = require(\"optipng\")\r\n}\r\nexports.PNGArrays = PNGArrays"]}